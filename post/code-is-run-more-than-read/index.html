<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>【译】代码运行多于阅读 | xxclick</title><meta name=keywords content><meta name=description content="原文🔗 链接。翻译由 Claude 3.5 Sonnet 驱动，部分翻译有增删。
1. 代码被阅读的次数多于被编写的次数 这句话如今已成为程序员的共识,提醒最初编写代码的人不应为了方便而牺牲未来需要阅读和修改代码的人的利益。更广泛地说,&ldquo;代码被阅读的次数多于被编写的次数&#34;传达了这样一个理念:通常来说,保持代码简单、编写测试和文档等方式来提高代码的可维护性是一项很好的投资。这是关于对软件开发周期有全局观的思考。
让我更简洁地表达这个想法:
维护者 > 作者
我认为这种思路可以延伸到代码编写之外,用作识别问题和做出决策的经验法则。
2. 代码被使用的次数多于被阅读的次数 代码是达到目的的手段。软件应该有一个目的,它应该为某些用户提供服务。如果软件不能实现其目的并为用户提供良好的体验,那么代码写得多么好、多么易于维护,或使用了多么复杂的技术都无关紧要:
用户 > 维护者 > 作者
或者,由于我们不再需要区分开发人员的角色:
用户 > 开发者
这就是为什么,与其猜测或询问用户需要什么,不如尽早且频繁地将程序展示给用户,并将我们从他们的反馈中学到的东西整合进来。
这是一个强大的思维模型,仅仅在开发过程中牢记用户就能让我们走得很远。这大约是我学习这份工作的方式,也是我职业生涯前半段对它的理解。
3. 代码运行的次数多于被阅读的次数 当我说&#34;运行&#34;时,我不仅仅指执行程序;我指的是在生产环境中操作它,包括所有相关的内容:部署、升级、观察、审计、监控、修复、停用等。正如 Dan McKinley 所说:
几乎总是如此,保持系统可靠运行的长期成本远远超过你在构建它时遇到的任何不便。
我们可以将这个想法纳入我们的小模型:
用户 > 运维 > 开发者
我花了一段时间才完全理解这一点,因为根据我的经验,很多正在构建的软件从未真正进入生产环境,至少没有达到显著的规模。大多数软件都是基于未经测试的假设构建的。但当你在生产环境中运行代码时,KISS（保持简单、愚蠢）原则就有了新的维度。它不仅仅是关于代码了;它是关于减少活动部件并理解它们的故障模式。它是关于发布东西并确保即使在失败时也能正常工作。
4. 还有业务 我说过,在开发过程中牢记用户可以让我们走得很远。这是基于这样一个假设:对用户有价值、有用且运行良好的软件对组织也会有价值。这对开发人员来说是一个方便的抽象:我们生产优秀、可用的软件,而业务部门负责将其转化为金钱。这在大多数情况下是有效的,特别是对于消费者和企业软件。但最终,这种抽象被证明是一种过度简化,我们可以通过将一些业务视角纳入我们的工作过程中而受益:
业务 > 用户 > 运维 > 开发者
最明显的例子是预算:我们没有无限的资源来满足用户需求,所以我们需要衡量成本和收益。还有营销,还有截止日期。有利益相关者和投资者。有个人利益和政治因素在起作用。有些决策对我们的软件、团队或用户来说是有意义的,但当我们考虑整个组织时就不一定了。有时,我们需要致力于创造收入,而不是取悦用户。我稍后会回到这个话题。
5. 问题迹象 我们得出了一个小模型,表达了软件开发中各种因素的相对重要性,这个模型也许能帮助我们看到更大的图景并专注于重要的事情。现在我想看看一些常见的软件开发问题,看看它们如何映射到这个模型中。
5.1 不可维护的代码 作者 > 维护者
这是我们的起点。这是聪明但懒惰的代码,最终变成意大利面条式的代码和恐怖森林,这是过早的优化,这是只有卡洛斯才能碰那个模块,等等。
5.2 不可用的软件 开发者 > 用户
来自不从用户那里学习或将技术放在首位的团队的软件。过度工程化的程序,&ldquo;现代化&#34;但降低了用户体验,破坏浏览器功能的网页应用等。
5.3 只在我的机器上运行 开发者 > 运维"><meta name=author content="xxclick"><link rel=canonical href=https://xxclick.github.io/post/code-is-run-more-than-read/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://xxclick.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://xxclick.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://xxclick.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://xxclick.github.io/apple-touch-icon.png><link rel=mask-icon href=https://xxclick.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="【译】代码运行多于阅读"><meta property="og:description" content="原文🔗 链接。翻译由 Claude 3.5 Sonnet 驱动，部分翻译有增删。
1. 代码被阅读的次数多于被编写的次数 这句话如今已成为程序员的共识,提醒最初编写代码的人不应为了方便而牺牲未来需要阅读和修改代码的人的利益。更广泛地说,&ldquo;代码被阅读的次数多于被编写的次数&#34;传达了这样一个理念:通常来说,保持代码简单、编写测试和文档等方式来提高代码的可维护性是一项很好的投资。这是关于对软件开发周期有全局观的思考。
让我更简洁地表达这个想法:
维护者 > 作者
我认为这种思路可以延伸到代码编写之外,用作识别问题和做出决策的经验法则。
2. 代码被使用的次数多于被阅读的次数 代码是达到目的的手段。软件应该有一个目的,它应该为某些用户提供服务。如果软件不能实现其目的并为用户提供良好的体验,那么代码写得多么好、多么易于维护,或使用了多么复杂的技术都无关紧要:
用户 > 维护者 > 作者
或者,由于我们不再需要区分开发人员的角色:
用户 > 开发者
这就是为什么,与其猜测或询问用户需要什么,不如尽早且频繁地将程序展示给用户,并将我们从他们的反馈中学到的东西整合进来。
这是一个强大的思维模型,仅仅在开发过程中牢记用户就能让我们走得很远。这大约是我学习这份工作的方式,也是我职业生涯前半段对它的理解。
3. 代码运行的次数多于被阅读的次数 当我说&#34;运行&#34;时,我不仅仅指执行程序;我指的是在生产环境中操作它,包括所有相关的内容:部署、升级、观察、审计、监控、修复、停用等。正如 Dan McKinley 所说:
几乎总是如此,保持系统可靠运行的长期成本远远超过你在构建它时遇到的任何不便。
我们可以将这个想法纳入我们的小模型:
用户 > 运维 > 开发者
我花了一段时间才完全理解这一点,因为根据我的经验,很多正在构建的软件从未真正进入生产环境,至少没有达到显著的规模。大多数软件都是基于未经测试的假设构建的。但当你在生产环境中运行代码时,KISS（保持简单、愚蠢）原则就有了新的维度。它不仅仅是关于代码了;它是关于减少活动部件并理解它们的故障模式。它是关于发布东西并确保即使在失败时也能正常工作。
4. 还有业务 我说过,在开发过程中牢记用户可以让我们走得很远。这是基于这样一个假设:对用户有价值、有用且运行良好的软件对组织也会有价值。这对开发人员来说是一个方便的抽象:我们生产优秀、可用的软件,而业务部门负责将其转化为金钱。这在大多数情况下是有效的,特别是对于消费者和企业软件。但最终,这种抽象被证明是一种过度简化,我们可以通过将一些业务视角纳入我们的工作过程中而受益:
业务 > 用户 > 运维 > 开发者
最明显的例子是预算:我们没有无限的资源来满足用户需求,所以我们需要衡量成本和收益。还有营销,还有截止日期。有利益相关者和投资者。有个人利益和政治因素在起作用。有些决策对我们的软件、团队或用户来说是有意义的,但当我们考虑整个组织时就不一定了。有时,我们需要致力于创造收入,而不是取悦用户。我稍后会回到这个话题。
5. 问题迹象 我们得出了一个小模型,表达了软件开发中各种因素的相对重要性,这个模型也许能帮助我们看到更大的图景并专注于重要的事情。现在我想看看一些常见的软件开发问题,看看它们如何映射到这个模型中。
5.1 不可维护的代码 作者 > 维护者
这是我们的起点。这是聪明但懒惰的代码,最终变成意大利面条式的代码和恐怖森林,这是过早的优化,这是只有卡洛斯才能碰那个模块,等等。
5.2 不可用的软件 开发者 > 用户
来自不从用户那里学习或将技术放在首位的团队的软件。过度工程化的程序,&ldquo;现代化&#34;但降低了用户体验,破坏浏览器功能的网页应用等。
5.3 只在我的机器上运行 开发者 > 运维"><meta property="og:type" content="article"><meta property="og:url" content="https://xxclick.github.io/post/code-is-run-more-than-read/"><meta property="og:image" content="https://xxclick.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="post"><meta property="article:published_time" content="2024-07-28T07:52:13+08:00"><meta property="article:modified_time" content="2024-07-28T07:52:13+08:00"><meta property="og:site_name" content="xxclick"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://xxclick.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="【译】代码运行多于阅读"><meta name=twitter:description content="原文🔗 链接。翻译由 Claude 3.5 Sonnet 驱动，部分翻译有增删。
1. 代码被阅读的次数多于被编写的次数 这句话如今已成为程序员的共识,提醒最初编写代码的人不应为了方便而牺牲未来需要阅读和修改代码的人的利益。更广泛地说,&ldquo;代码被阅读的次数多于被编写的次数&#34;传达了这样一个理念:通常来说,保持代码简单、编写测试和文档等方式来提高代码的可维护性是一项很好的投资。这是关于对软件开发周期有全局观的思考。
让我更简洁地表达这个想法:
维护者 > 作者
我认为这种思路可以延伸到代码编写之外,用作识别问题和做出决策的经验法则。
2. 代码被使用的次数多于被阅读的次数 代码是达到目的的手段。软件应该有一个目的,它应该为某些用户提供服务。如果软件不能实现其目的并为用户提供良好的体验,那么代码写得多么好、多么易于维护,或使用了多么复杂的技术都无关紧要:
用户 > 维护者 > 作者
或者,由于我们不再需要区分开发人员的角色:
用户 > 开发者
这就是为什么,与其猜测或询问用户需要什么,不如尽早且频繁地将程序展示给用户,并将我们从他们的反馈中学到的东西整合进来。
这是一个强大的思维模型,仅仅在开发过程中牢记用户就能让我们走得很远。这大约是我学习这份工作的方式,也是我职业生涯前半段对它的理解。
3. 代码运行的次数多于被阅读的次数 当我说&#34;运行&#34;时,我不仅仅指执行程序;我指的是在生产环境中操作它,包括所有相关的内容:部署、升级、观察、审计、监控、修复、停用等。正如 Dan McKinley 所说:
几乎总是如此,保持系统可靠运行的长期成本远远超过你在构建它时遇到的任何不便。
我们可以将这个想法纳入我们的小模型:
用户 > 运维 > 开发者
我花了一段时间才完全理解这一点,因为根据我的经验,很多正在构建的软件从未真正进入生产环境,至少没有达到显著的规模。大多数软件都是基于未经测试的假设构建的。但当你在生产环境中运行代码时,KISS（保持简单、愚蠢）原则就有了新的维度。它不仅仅是关于代码了;它是关于减少活动部件并理解它们的故障模式。它是关于发布东西并确保即使在失败时也能正常工作。
4. 还有业务 我说过,在开发过程中牢记用户可以让我们走得很远。这是基于这样一个假设:对用户有价值、有用且运行良好的软件对组织也会有价值。这对开发人员来说是一个方便的抽象:我们生产优秀、可用的软件,而业务部门负责将其转化为金钱。这在大多数情况下是有效的,特别是对于消费者和企业软件。但最终,这种抽象被证明是一种过度简化,我们可以通过将一些业务视角纳入我们的工作过程中而受益:
业务 > 用户 > 运维 > 开发者
最明显的例子是预算:我们没有无限的资源来满足用户需求,所以我们需要衡量成本和收益。还有营销,还有截止日期。有利益相关者和投资者。有个人利益和政治因素在起作用。有些决策对我们的软件、团队或用户来说是有意义的,但当我们考虑整个组织时就不一定了。有时,我们需要致力于创造收入,而不是取悦用户。我稍后会回到这个话题。
5. 问题迹象 我们得出了一个小模型,表达了软件开发中各种因素的相对重要性,这个模型也许能帮助我们看到更大的图景并专注于重要的事情。现在我想看看一些常见的软件开发问题,看看它们如何映射到这个模型中。
5.1 不可维护的代码 作者 > 维护者
这是我们的起点。这是聪明但懒惰的代码,最终变成意大利面条式的代码和恐怖森林,这是过早的优化,这是只有卡洛斯才能碰那个模块,等等。
5.2 不可用的软件 开发者 > 用户
来自不从用户那里学习或将技术放在首位的团队的软件。过度工程化的程序,&ldquo;现代化&#34;但降低了用户体验,破坏浏览器功能的网页应用等。
5.3 只在我的机器上运行 开发者 > 运维"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://xxclick.github.io/post/"},{"@type":"ListItem","position":2,"name":"【译】代码运行多于阅读","item":"https://xxclick.github.io/post/code-is-run-more-than-read/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"【译】代码运行多于阅读","name":"【译】代码运行多于阅读","description":"原文🔗 链接。翻译由 Claude 3.5 Sonnet 驱动，部分翻译有增删。\n1. 代码被阅读的次数多于被编写的次数 这句话如今已成为程序员的共识,提醒最初编写代码的人不应为了方便而牺牲未来需要阅读和修改代码的人的利益。更广泛地说,\u0026ldquo;代码被阅读的次数多于被编写的次数\u0026quot;传达了这样一个理念:通常来说,保持代码简单、编写测试和文档等方式来提高代码的可维护性是一项很好的投资。这是关于对软件开发周期有全局观的思考。\n让我更简洁地表达这个想法:\n维护者 \u0026gt; 作者\n我认为这种思路可以延伸到代码编写之外,用作识别问题和做出决策的经验法则。\n2. 代码被使用的次数多于被阅读的次数 代码是达到目的的手段。软件应该有一个目的,它应该为某些用户提供服务。如果软件不能实现其目的并为用户提供良好的体验,那么代码写得多么好、多么易于维护,或使用了多么复杂的技术都无关紧要:\n用户 \u0026gt; 维护者 \u0026gt; 作者\n或者,由于我们不再需要区分开发人员的角色:\n用户 \u0026gt; 开发者\n这就是为什么,与其猜测或询问用户需要什么,不如尽早且频繁地将程序展示给用户,并将我们从他们的反馈中学到的东西整合进来。\n这是一个强大的思维模型,仅仅在开发过程中牢记用户就能让我们走得很远。这大约是我学习这份工作的方式,也是我职业生涯前半段对它的理解。\n3. 代码运行的次数多于被阅读的次数 当我说\u0026quot;运行\u0026quot;时,我不仅仅指执行程序;我指的是在生产环境中操作它,包括所有相关的内容:部署、升级、观察、审计、监控、修复、停用等。正如 Dan McKinley 所说:\n几乎总是如此,保持系统可靠运行的长期成本远远超过你在构建它时遇到的任何不便。\n我们可以将这个想法纳入我们的小模型:\n用户 \u0026gt; 运维 \u0026gt; 开发者\n我花了一段时间才完全理解这一点,因为根据我的经验,很多正在构建的软件从未真正进入生产环境,至少没有达到显著的规模。大多数软件都是基于未经测试的假设构建的。但当你在生产环境中运行代码时,KISS（保持简单、愚蠢）原则就有了新的维度。它不仅仅是关于代码了;它是关于减少活动部件并理解它们的故障模式。它是关于发布东西并确保即使在失败时也能正常工作。\n4. 还有业务 我说过,在开发过程中牢记用户可以让我们走得很远。这是基于这样一个假设:对用户有价值、有用且运行良好的软件对组织也会有价值。这对开发人员来说是一个方便的抽象:我们生产优秀、可用的软件,而业务部门负责将其转化为金钱。这在大多数情况下是有效的,特别是对于消费者和企业软件。但最终,这种抽象被证明是一种过度简化,我们可以通过将一些业务视角纳入我们的工作过程中而受益:\n业务 \u0026gt; 用户 \u0026gt; 运维 \u0026gt; 开发者\n最明显的例子是预算:我们没有无限的资源来满足用户需求,所以我们需要衡量成本和收益。还有营销,还有截止日期。有利益相关者和投资者。有个人利益和政治因素在起作用。有些决策对我们的软件、团队或用户来说是有意义的,但当我们考虑整个组织时就不一定了。有时,我们需要致力于创造收入,而不是取悦用户。我稍后会回到这个话题。\n5. 问题迹象 我们得出了一个小模型,表达了软件开发中各种因素的相对重要性,这个模型也许能帮助我们看到更大的图景并专注于重要的事情。现在我想看看一些常见的软件开发问题,看看它们如何映射到这个模型中。\n5.1 不可维护的代码 作者 \u0026gt; 维护者\n这是我们的起点。这是聪明但懒惰的代码,最终变成意大利面条式的代码和恐怖森林,这是过早的优化,这是只有卡洛斯才能碰那个模块,等等。\n5.2 不可用的软件 开发者 \u0026gt; 用户\n来自不从用户那里学习或将技术放在首位的团队的软件。过度工程化的程序,\u0026ldquo;现代化\u0026quot;但降低了用户体验,破坏浏览器功能的网页应用等。\n5.3 只在我的机器上运行 开发者 \u0026gt; 运维","keywords":[],"articleBody":" 原文🔗 链接。翻译由 Claude 3.5 Sonnet 驱动，部分翻译有增删。\n1. 代码被阅读的次数多于被编写的次数 这句话如今已成为程序员的共识,提醒最初编写代码的人不应为了方便而牺牲未来需要阅读和修改代码的人的利益。更广泛地说,“代码被阅读的次数多于被编写的次数\"传达了这样一个理念:通常来说,保持代码简单、编写测试和文档等方式来提高代码的可维护性是一项很好的投资。这是关于对软件开发周期有全局观的思考。\n让我更简洁地表达这个想法:\n维护者 \u003e 作者\n我认为这种思路可以延伸到代码编写之外,用作识别问题和做出决策的经验法则。\n2. 代码被使用的次数多于被阅读的次数 代码是达到目的的手段。软件应该有一个目的,它应该为某些用户提供服务。如果软件不能实现其目的并为用户提供良好的体验,那么代码写得多么好、多么易于维护,或使用了多么复杂的技术都无关紧要:\n用户 \u003e 维护者 \u003e 作者\n或者,由于我们不再需要区分开发人员的角色:\n用户 \u003e 开发者\n这就是为什么,与其猜测或询问用户需要什么,不如尽早且频繁地将程序展示给用户,并将我们从他们的反馈中学到的东西整合进来。\n这是一个强大的思维模型,仅仅在开发过程中牢记用户就能让我们走得很远。这大约是我学习这份工作的方式,也是我职业生涯前半段对它的理解。\n3. 代码运行的次数多于被阅读的次数 当我说\"运行\"时,我不仅仅指执行程序;我指的是在生产环境中操作它,包括所有相关的内容:部署、升级、观察、审计、监控、修复、停用等。正如 Dan McKinley 所说:\n几乎总是如此,保持系统可靠运行的长期成本远远超过你在构建它时遇到的任何不便。\n我们可以将这个想法纳入我们的小模型:\n用户 \u003e 运维 \u003e 开发者\n我花了一段时间才完全理解这一点,因为根据我的经验,很多正在构建的软件从未真正进入生产环境,至少没有达到显著的规模。大多数软件都是基于未经测试的假设构建的。但当你在生产环境中运行代码时,KISS（保持简单、愚蠢）原则就有了新的维度。它不仅仅是关于代码了;它是关于减少活动部件并理解它们的故障模式。它是关于发布东西并确保即使在失败时也能正常工作。\n4. 还有业务 我说过,在开发过程中牢记用户可以让我们走得很远。这是基于这样一个假设:对用户有价值、有用且运行良好的软件对组织也会有价值。这对开发人员来说是一个方便的抽象:我们生产优秀、可用的软件,而业务部门负责将其转化为金钱。这在大多数情况下是有效的,特别是对于消费者和企业软件。但最终,这种抽象被证明是一种过度简化,我们可以通过将一些业务视角纳入我们的工作过程中而受益:\n业务 \u003e 用户 \u003e 运维 \u003e 开发者\n最明显的例子是预算:我们没有无限的资源来满足用户需求,所以我们需要衡量成本和收益。还有营销,还有截止日期。有利益相关者和投资者。有个人利益和政治因素在起作用。有些决策对我们的软件、团队或用户来说是有意义的,但当我们考虑整个组织时就不一定了。有时,我们需要致力于创造收入,而不是取悦用户。我稍后会回到这个话题。\n5. 问题迹象 我们得出了一个小模型,表达了软件开发中各种因素的相对重要性,这个模型也许能帮助我们看到更大的图景并专注于重要的事情。现在我想看看一些常见的软件开发问题,看看它们如何映射到这个模型中。\n5.1 不可维护的代码 作者 \u003e 维护者\n这是我们的起点。这是聪明但懒惰的代码,最终变成意大利面条式的代码和恐怖森林,这是过早的优化,这是只有卡洛斯才能碰那个模块,等等。\n5.2 不可用的软件 开发者 \u003e 用户\n来自不从用户那里学习或将技术放在首位的团队的软件。过度工程化的程序,“现代化\"但降低了用户体验,破坏浏览器功能的网页应用等。\n5.3 只在我的机器上运行 开发者 \u003e 运维\n没有考虑到其运行环境而设计的软件。这是过于复杂的软件,有很多活动部件,为小数据负载使用 fancy 数据库,由单个小团队管理的微服务生态系统。过早为规模而设计的软件。由与半夜被叫醒解决问题的人不同的人设计的软件。\n5.4 正确的事 开发者 \u003e 业务\n将代码视为目的本身。由自命不凡的工匠、泰坦尼克号上的音乐家和 Lisp 黑客构建的软件。\n5.5 简历驱动开发 开发者 \u003e *\n当没有什么利害关系而开发人员可以为所欲为时产生的软件。\n5.6 想象中的软件 业务 \u003e 用户 \u003e 运维 \u003e 开发者\n这是构建了但很少（或从未）进入生产环境的软件。我称之为想象中的软件。Charity Majors 称之为活在谎言中。\n业务 \u003e 用户 \u003e 运维 \u003e 开发者\n另一种想象中的软件是没有用户的软件。（但可以扩展）。这是不能解决问题,或解决了错误的问题,也许是没人的问题的软件。这种软件是从一些炒作的技术开始,然后用它敲打一切,直到出现一个模糊类似用例的东西。\n5.7 晚期资本主义 业务 \u003e 用户 \u003e 运维 \u003e 开发者\n没有商业模式或其商业模式是增长直到垄断然后剥削用户的风险投资支持的软件。\n6. 一头大象 如果你还没有愤怒地关闭浏览器标签,让我总结一下回到这个问题:\n业务 \u003e 用户\n这个问题有一些难以接受的影响。\n正如我之前提到的,按照我学习这份工作的方式,软件是关于为最终用户解决问题的。这在《程序员修炼之道》的最后一个提示中得到了总结,说我们的目标是取悦用户,而不仅仅是交付代码。但是,自从我开始作为程序员工作以来,随着软件变得无处不在,我看到这个假设变得越来越难以维持。\n有很多正在生产的软件根本不关心它的用户,或者操纵他们,或者将他们变成产品。这不仅限于社交媒体:作为一个用户,我甚至无法预订房间、点餐或点击 Windows 开始按钮而不被弹出窗口试图抓住我的注意力;我无法进行 Google 搜索而不得到一堆垃圾。\n我们认为做好工作的内容与行业中相当一部分人认为有利可图的内容之间存在不匹配,我认为这解释了许多软件专业人士日益增加的不适感。虽然我们不能仅仅回到忽视我们学科的经济现实,但也许我们应该采取更强硬的道德立场不去伤害用户。承认用户可能并不总是比业务更重要,但业务也不应无条件地排在首位:\n用户 \u003e 运维 \u003e 开发者\n业务 \u003e 运维 \u003e 开发者\n业务 ≹ 用户\n","wordCount":"147","inLanguage":"en","datePublished":"2024-07-28T07:52:13+08:00","dateModified":"2024-07-28T07:52:13+08:00","author":{"@type":"Person","name":"xxclick"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://xxclick.github.io/post/code-is-run-more-than-read/"},"publisher":{"@type":"Organization","name":"xxclick","logo":{"@type":"ImageObject","url":"https://xxclick.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://xxclick.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://xxclick.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://xxclick.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://xxclick.github.io/post/>Posts</a></div><h1 class="post-title entry-hint-parent">【译】代码运行多于阅读</h1><div class=post-meta><span title='2024-07-28 07:52:13 +0800 CST'>28.07.2024</span>&nbsp;·&nbsp;xxclick</div></header><div class=post-content><blockquote><p>原文<a href=https://olano.dev/blog/code-is-run-more-than-read/>🔗 链接</a>。翻译由 Claude 3.5 Sonnet 驱动，部分翻译有增删。</p></blockquote><h2 id=1-代码被阅读的次数多于被编写的次数>1. 代码被阅读的次数多于被编写的次数<a hidden class=anchor aria-hidden=true href=#1-代码被阅读的次数多于被编写的次数>#</a></h2><p>这句话如今已成为程序员的共识,提醒最初编写代码的人不应为了方便而牺牲未来需要阅读和修改代码的人的利益。更广泛地说,&ldquo;代码被阅读的次数多于被编写的次数"传达了这样一个理念:通常来说,保持代码简单、编写测试和文档等方式来提高代码的可维护性是一项很好的投资。这是关于对软件开发周期有全局观的思考。</p><p>让我更简洁地表达这个想法:</p><p><code>维护者 > 作者</code></p><p>我认为这种思路可以延伸到代码编写之外,用作识别问题和做出决策的经验法则。</p><h2 id=2-代码被使用的次数多于被阅读的次数>2. 代码被使用的次数多于被阅读的次数<a hidden class=anchor aria-hidden=true href=#2-代码被使用的次数多于被阅读的次数>#</a></h2><p>代码是达到目的的手段。软件应该有一个目的,它应该为某些用户提供服务。如果软件不能实现其目的并为用户提供良好的体验,那么代码写得多么好、多么易于维护,或使用了多么复杂的技术都无关紧要:</p><p><code>用户 > 维护者 > 作者</code></p><p>或者,由于我们不再需要区分开发人员的角色:</p><p><code>用户 > 开发者</code></p><p>这就是为什么,与其猜测或询问用户需要什么,不如尽早且频繁地将程序展示给用户,并将我们从他们的反馈中学到的东西整合进来。</p><p>这是一个强大的思维模型,仅仅在开发过程中牢记用户就能让我们走得很远。这大约是我学习这份工作的方式,也是我职业生涯前半段对它的理解。</p><h2 id=3-代码运行的次数多于被阅读的次数>3. 代码运行的次数多于被阅读的次数<a hidden class=anchor aria-hidden=true href=#3-代码运行的次数多于被阅读的次数>#</a></h2><p>当我说"运行"时,我不仅仅指执行程序;我指的是在生产环境中操作它,包括所有相关的内容:部署、升级、观察、审计、监控、修复、停用等。正如 Dan McKinley 所说:</p><blockquote><p>几乎总是如此,保持系统可靠运行的长期成本远远超过你在构建它时遇到的任何不便。</p></blockquote><p>我们可以将这个想法纳入我们的小模型:</p><p><code>用户 > 运维 > 开发者</code></p><p>我花了一段时间才完全理解这一点,因为根据我的经验,很多正在构建的软件从未真正进入生产环境,至少没有达到显著的规模。大多数软件都是基于未经测试的假设构建的。但当你在生产环境中运行代码时,<code>KISS</code>（保持简单、愚蠢）原则就有了新的维度。它不仅仅是关于代码了;它是关于减少活动部件并理解它们的故障模式。它是关于发布东西并确保即使在失败时也能正常工作。</p><h2 id=4-还有业务>4. 还有业务<a hidden class=anchor aria-hidden=true href=#4-还有业务>#</a></h2><p>我说过,在开发过程中牢记用户可以让我们走得很远。这是基于这样一个假设:对用户有价值、有用且运行良好的软件对组织也会有价值。这对开发人员来说是一个方便的抽象:我们生产优秀、可用的软件,而业务部门负责将其转化为金钱。这在大多数情况下是有效的,特别是对于消费者和企业软件。但最终,这种抽象被证明是一种过度简化,我们可以通过将一些业务视角纳入我们的工作过程中而受益:</p><p><code>业务 > 用户 > 运维 > 开发者</code></p><p>最明显的例子是预算:我们没有无限的资源来满足用户需求,所以我们需要衡量成本和收益。还有营销,还有截止日期。有利益相关者和投资者。有个人利益和政治因素在起作用。有些决策对我们的软件、团队或用户来说是有意义的,但当我们考虑整个组织时就不一定了。有时,我们需要致力于创造收入,而不是取悦用户。我稍后会回到这个话题。</p><h2 id=5-问题迹象>5. 问题迹象<a hidden class=anchor aria-hidden=true href=#5-问题迹象>#</a></h2><p>我们得出了一个小模型,表达了软件开发中各种因素的相对重要性,这个模型也许能帮助我们看到更大的图景并专注于重要的事情。现在我想看看一些常见的软件开发问题,看看它们如何映射到这个模型中。</p><h3 id=51-不可维护的代码>5.1 不可维护的代码<a hidden class=anchor aria-hidden=true href=#51-不可维护的代码>#</a></h3><p><code>作者 > 维护者</code></p><p>这是我们的起点。这是聪明但懒惰的代码,最终变成意大利面条式的代码和恐怖森林,这是过早的优化,这是只有卡洛斯才能碰那个模块,等等。</p><h3 id=52-不可用的软件>5.2 不可用的软件<a hidden class=anchor aria-hidden=true href=#52-不可用的软件>#</a></h3><p><code>开发者 > 用户</code></p><p>来自不从用户那里学习或将技术放在首位的团队的软件。过度工程化的程序,&ldquo;现代化"但降低了用户体验,破坏浏览器功能的网页应用等。</p><h3 id=53-只在我的机器上运行>5.3 只在我的机器上运行<a hidden class=anchor aria-hidden=true href=#53-只在我的机器上运行>#</a></h3><p><code>开发者 > 运维</code></p><p>没有考虑到其运行环境而设计的软件。这是过于复杂的软件,有很多活动部件,为小数据负载使用 fancy 数据库,由单个小团队管理的微服务生态系统。过早为规模而设计的软件。由与半夜被叫醒解决问题的人不同的人设计的软件。</p><h3 id=54-正确的事>5.4 正确的事<a hidden class=anchor aria-hidden=true href=#54-正确的事>#</a></h3><p><code>开发者 > 业务</code></p><p>将代码视为目的本身。由自命不凡的工匠、泰坦尼克号上的音乐家和 Lisp 黑客构建的软件。</p><h3 id=55-简历驱动开发>5.5 简历驱动开发<a hidden class=anchor aria-hidden=true href=#55-简历驱动开发>#</a></h3><p><code>开发者 > *</code></p><p>当没有什么利害关系而开发人员可以为所欲为时产生的软件。</p><h3 id=56-想象中的软件>5.6 想象中的软件<a hidden class=anchor aria-hidden=true href=#56-想象中的软件>#</a></h3><p>业务 > 用户 > <del>运维</del> > 开发者</p><p>这是构建了但很少（或从未）进入生产环境的软件。我称之为想象中的软件。Charity Majors 称之为活在谎言中。</p><p>业务 > <del>用户</del> > 运维 > 开发者</p><p>另一种想象中的软件是没有用户的软件。（但可以扩展）。这是不能解决问题,或解决了错误的问题,也许是没人的问题的软件。这种软件是从一些炒作的技术开始,然后用它敲打一切,直到出现一个模糊类似用例的东西。</p><h3 id=57-晚期资本主义>5.7 晚期资本主义<a hidden class=anchor aria-hidden=true href=#57-晚期资本主义>#</a></h3><p><del>业务</del> > 用户 > 运维 > 开发者</p><p>没有商业模式或其商业模式是增长直到垄断然后剥削用户的风险投资支持的软件。</p><h2 id=6-一头大象>6. 一头大象<a hidden class=anchor aria-hidden=true href=#6-一头大象>#</a></h2><p>如果你还没有愤怒地关闭浏览器标签,让我总结一下回到这个问题:</p><p><code>业务 > 用户</code></p><p>这个问题有一些难以接受的影响。</p><p>正如我之前提到的,按照我学习这份工作的方式,软件是关于为最终用户解决问题的。这在《程序员修炼之道》的最后一个提示中得到了总结,说我们的目标是取悦用户,而不仅仅是交付代码。但是,自从我开始作为程序员工作以来,随着软件变得无处不在,我看到这个假设变得越来越难以维持。</p><p>有很多正在生产的软件根本不关心它的用户,或者操纵他们,或者将他们变成产品。这不仅限于社交媒体:作为一个用户,我甚至无法预订房间、点餐或点击 Windows 开始按钮而不被弹出窗口试图抓住我的注意力;我无法进行 Google 搜索而不得到一堆垃圾。</p><p>我们认为做好工作的内容与行业中相当一部分人认为有利可图的内容之间存在不匹配,我认为这解释了许多软件专业人士日益增加的不适感。虽然我们不能仅仅回到忽视我们学科的经济现实,但也许我们应该采取更强硬的道德立场不去伤害用户。承认用户可能并不总是比业务更重要,但业务也不应无条件地排在首位:</p><p><code>用户 > 运维 > 开发者</code></p><p><code>业务 > 运维 > 开发者</code></p><p><code>业务 ≹ 用户</code></p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=next href=https://xxclick.github.io/post/storyteller/><span class=title>Next »</span><br><span>【转】讲故事的人</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://xxclick.github.io/>xxclick</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>